import numpy as np
import pybullet as p
import pybullet_data
import time
import os
import sys
import matplotlib.pyplot as plt
sys.path.append('/Users/lucaspeters/Desktop/pdm/PythonRobotics/PathPlanning/RRTStar')
from rrt_star import RRTStar


# Import the Drone class from its script file
from drone import Drone

# Load the functions defined in other scripts
from control_scripts.add_obstacles import add_obstacles
from control_scripts.control_mpc import mpc_control_drone
from control_scripts.control_mpc import is_waypoint_reached
from control_scripts.add_obstacles import move_the_column
from control_scripts.add_obstacles import get_dynamical_obstacles_info

# Initialize the simulation
p.connect(p.GUI)
p.resetSimulation()
p.setRealTimeSimulation(0)
p.setGravity(0, 0, -9.81)
p.loadURDF(os.path.join(pybullet_data.getDataPath(), "plane.urdf"), [0, 0, 0])

# Add obstacles to the simulation and list them in a list
obstacles = [
    [0, 1, 0.25], [1, 1, 0.25], [2, 1, 0.25],
    [0, 2, 0.25], [1, 2, 0.25], [2, 2, 0.25],
    [0, 3, 0.25], [1, 3, 0.25], [2, 3, 0.25],
    [0, 4, 0.25], [1, 4, 0.25], [2, 4, 0.25]
]

# Define the start and goal positions
start_position = [0, 0, 0.25 + 0.5]
goal_position = [2, 5.5, 0.7]



# Run RRT* algorithm
# Run RRT* algorithm
rrt_star = RRTStar(
    start=start_position,
    goal=goal_position,
    obstacle_list=obstacles,
    rand_area=[-5, 5],  # Adjust the rand_area based on your requirements
    expand_dis=0.1,  # Adjust the expand_dis based on your requirements
    path_resolution=0.1,  # Adjust the path_resolution based on your requirements
    goal_sample_rate=20,  # Adjust the goal_sample_rate based on your requirements
    max_iter=1000
)
path = rrt_star.planning(animation=True)

# Print the path
print("Path:", path)

rrt_star.draw_graph()
plt.plot([x for (x, y) in path], [y for (x, y) in path], 'r--')
plt.grid(True)
plt.show()